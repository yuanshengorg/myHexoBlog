---
title: JavaScript（五）函数、作用域、预解析
categories: JavaScript
tags: js
date: 
---



## 函数

-   函数就是封装了一段可被重复调用执行的代码块；
-   通过此代码块可以**实现大量代码的重复使用**；

### 声明函数

-   function 是声明函数的关键字,必须小写；
-   由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum；

``` js
// 声明函数
function 函数名() {
    //函数体代码
}
```

### 调用函数

-   调用时要加小括号；
-   口诀：函数不调用，自己不执行；
-   声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码；

``` js
// 调用函数
函数名();  // 通过调用函数名来执行函数体代码
```

例子：封装计算1-100累加和

``` js
// 声明函数
function getSum(){
    var sumNum = 0; // 准备一个变量，保存数字和
    for (var i = 1; i <= 100; i++) {
        sumNum += i; // 把每个数值 都累加 到变量中
    }
    alert(sumNum);
}
// 调用函数
getSum();
```



### 函数的参数

-   形参：函数定义时设置接收调用时传入；
-   实参：函数调用时传入小括号内的真实数据；
-   调用的时候实参值是传递给形参的；
-   形参简单理解为：不用声明的变量；
-   实参和形参的多个参数之间用逗号（ , ）分隔；

``` js
// 带参数的函数声明
function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔
  // 函数体
}
// 带参数的函数调用
函数名(实参1, 实参2, 实参3...); 
```

函数形参和实参数量不匹配时：

-   实参个数 = 形参个数：正确；
-   实参个数 > 形参个数：只取到形参的个数；
-   实参个数 < 形参个数：多的形参为undefined，结果为NaN；
-   在JavaScript中，形参的默认值是undefined；

小结：

-   函数可以带参数也可以不带参数；
-   声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined；
-   调用函数的时候，函数名括号里面的是实参；
-   多个参数中间用逗号分隔；
-   形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配；





### 函数的返回值

return 语句

-   在使用 return 语句时，函数会停止执行，并返回指定的值；
-   如果函数没有 return ，返回的值是 undefined；

``` js
// 声明函数
function 函数名（）{
    ...
    return  需要返回的值；
}
// 调用函数
函数名();    // 此时调用函数就可以得到函数体内return 后面的值
```



### break、continue 和 return

-   break ：结束当前的循环体（如 for、while）；
-   continue ：跳出本次循环，继续执行下次循环（如 for、while）；
-   return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码；





### arguments 不确定参数

-   不确定有多少个参数传递的时候，可以用 arguments 来获取；
-   JavaScript 中，arguments实际上它是当前函数的一个内置对象；
-   所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参；
-   arguments展示形式是一个伪数组，因此可以进行遍历；
-   伪数组具有以下特点：
    -   具有 length 属性；
    -   按索引方式储存数据；
    -   不具有数组的 push , pop 等方法；
    -   注意：在函数内部使用该对象，用此对象获取函数调用时传的实参；



### 函数内部调用其他函数

函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。



### 函数声明方式

自定义函数方式 (**命名函数**)：

-   利用函数关键字 function 自定义函数方式；
-   因为有名字，所以也被称为命名函数；
-   调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面；

```js
// 声明定义方式
function fn1() {
    ...
};
// 调用  
fn1();  
```



函数表达式方式 (**匿名函数**）：

-   因为函数没有名字，所以也被称为匿名函数；
-   这个fn 里面存储的是一个函数  ；
-   函数表达式方式原理跟声明变量方式是一致的；
-   函数调用的代码必须写到函数体后面；

```js
// 这是函数表达式写法，匿名函数后面跟分号结束
var fn2 = function( ) {
    ...
}；
// 调用的方式，函数调用必须写到函数体下面
fn2();
```





## 作用域、预解析

### 作用域

-   全局作用域
    -   作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件。
-   局部作用域
    -   作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。
-   JS没有块级作用域
    -   块作用域由 { } 包括。

java有块级作用域：

``` java
if (true) {
  int num = 123;
  system.out.print(num);  // 123
}
system.out.print(num);    // 报错
```

-   以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；

-   而与之类似的JavaScript代码，则不会报错：

Js中没有块级作用域（在ES6之前）

``` js
if (true) {
    var num = 123;
    console.log(123); //123
}
console.log(123);   //123
```



### 全局变量和局部变量

-   全局变量
    -   在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。
    -   全局变量在代码的任何位置都可以使用
    -   在全局作用域下 var 声明的变量 是全局变量
    -   特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用）
-   局部变量
    -   局部变量只能在该函数内部使用
    -   在函数内部 var 声明的变量是局部变量
    -   函数的形参实际上就是局部变量
-   全局变量和局部变量的区别
    -   全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存
    -   局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间



### 作用域链

-   只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；
-   如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；
-   根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链

``` js
function f1() {
    var num = 123;
    function f2() {
        console.log( num );
    }
    f2();
}
var num = 456;
f1();
```

作用域链：采取就近原则的方式来查找变量最终的值。

``` js
var a = 1;
function fn1() {
    var a = 2;
    var b = '22';
    fn2();
    function fn2() {
        var a = 3;
        fn3();
        function fn3() {
            var a = 4;
            console.log(a); //a的值 ?
            console.log(b); //b的值 ?
        }
    }
}
fn1();
```

![](http://mdimg.95408.com/202001060155_624.png?null)





### 预解析

-   JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。
-   预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义。
-   代码执行： 从上到下执行JS语句。
-   预解析会把变量和函数的声明在代码执行之前执行完成。

**变量预解析**

-   预解析也叫做变量、函数提升。
-   变量提升（变量预解析）： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。

``` js
console.log(num);  // 结果是多少？
var num = 10;      
// 结果：undefined
// 相当于：
// 注意：变量提升只提升声明，不提升赋值
var num;
console.log(num); // undefined
num = 10;
```



**函数预解析**

-   函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。

``` js
fn();
function fn() {
    console.log('打印');
}
// 结果：输出字符串 --- 打印
// 相当于：
// 函数声明代表函数整体
// 函数提升后，函数名代表整个函数，但函数并没有被调用
function fn() {
    console.log('打印');
}
fn();
```



**函数表达式声明函数问题**

-   函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用：

``` js
fn();
var fn = function() {
    console.log('想不到吧');
}
// 结果：报错提示 ”fn is not a function"
// 先做变量声明提升，fn在提升之后的值是undefined；
// fn调用是在fn被赋值为函数体之前
// 此时fn的值是undefined，所以无法正确调用
// 相当于：
var fn;
fn();
fn = function() {
    console.log('想不到吧');
}
```





以上。



















































